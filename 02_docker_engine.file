## 2장 도커 엔진

docker pull --platform linux/amd64 mysql:5.7

mysql --host=localhost --port=3306 --user=root --password=123123

mysql> show databases;

docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=123123 -e MYSQL_DATABASE=wordpress mysql:5.7
docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=123123 -e MYSQL_DATABASE=wordpress mysql:8.0

docker stop wordpress
docker rm wordpress
docker run -d -e WORDPRESS_DB_PASSWORD=123123 --name wordpress --link wordpressdb:mysql -p 48080:80 wordpress

docker inspect -f '{{.State.Pid}}' wordpress
sudo nsenter -t [container-pid] -n netstat -tupln
sudo nsenter -t 11130 -n netstat -tupln

docker run -i -t \
--name mysql_attach_test \
-e MYSQL_ROOT_PASSWORD=123123 \
-e MYSQL_DATABASE=testdb \
mysql:5.7

docker exec -it wordpressdb /bin/bash
docker exec -it wordpressdb mysql --host=localhost --port=3306 --user=root --password=123123

docker exec wordpressdb mysql --host=localhost --port=3306 --user=root --password=123123 -e "show databases;"
docker exec wordpress curl mysql:3306 --silent

---

# 볼륨 사용 방법 3종류
## 호스트와 볼륨 공유 : 마운트
## 볼륨 컨테이너 : 볼륨으로 사용할 컨테이너를 생성 => 생략
## 도커가 관리하는 볼륨 : 도커 볼륨

---

# 호스트와 볼륨 공유

docker run -d --name wordpressdb_hostvolume \
-e MYSQL_ROOT_PASSWORD=123123 \
-e MYSQL_DATABASE=wordpress \
-v ~/space/wordpress_db:/var/lib/mysql \
mysql:5.7

docker run -d --name wordpress_hostvolume \
-e WORDPRESS_DB_PASSWORD=123123 \
--link wordpressdb_hostvolume:mysql \
-p 48080:80 \
wordpress

ls ~/space/wordpress_db

docker stop wordpressdb_hostvolume wordpress_hostvolume
docker rm wordpressdb_hostvolume wordpress_hostvolume

---

# 파일 단위 볼륨 사용

echo hello >> ~/space/hello && echo hello2 >> ~/space/hello2
docker run -i -t --name file_volume \
-v ~/space/hello:/hello \
-v ~/space/hello2:/hello2 \
ubuntu:14.04

---

# 도커 볼륨

docker volume create --name myvolume
docker volume ls

docker run -it --name myvolume_1 -v myvolume:/root/ ubuntu:14.04
echo "hello myvolume" >> /root/volume
docker run -it --name myvolume_2 -v myvolume:/root/ ubuntu:14.04
cat /root/volume

---

# 볼륨 정보 조회

docker inspect --type volume myvolume
ls /var/lib/docker/volumes/myvolume/_data
cat /var/lib/docker/volumes/myvolume/_data/volume

# 도커 볼륨 미지정 시, 도커 볼륨 자동 생성

docker run -it --name volume_auto \
-v /root \
ubuntu:14.04
docker volume ls
docker container inspect volume_auto | grep -i source

---

# 사용하지 않는 볼륨 삭제
docker volume prune

---

# mount 옵션

docker run -it --name mount_option_1 \
--mount type=volume,source=myvolume,target=/root \
ubuntu:14.04

# bind 에서, 상대 경로 안됨, 호스트 폴더 이미 존재해야 함
mkdir -p /Users/user/space/wordpress_db
docker run -it --name mount_option_2 \
--mount type=bind,source=/Users/user/space/wordpress_db,target=/home/testdir \
ubuntu:14.04

---

# 도커 네트워크

# 도커는 컨테이너 내부 IP 를 순차적으로 할당
# 컨테이너가 외부와 네트워크 통신을 위해 가상 네트워크 인터페이스를 생성
# veth = 가상 네트워크 인터페이스
# veth 호스트에 생성됨, 각 컨테이너 수만큼 vethxxx 생성됨, 도커 엔진이 자동 생성함

# 근데, mac 도커 데스크탑 환경에서는 veth 인터페이스가 안보인단 말이지 !
# ubuntu 컨테이너 하나를 host 네트워크 모드로 생성하면, vethxxx 인터페이스가 보임 !

---

# 도커 네트워크 드라이버
# 브리지 bridge
# 호스트 host
# 논 none
# 컨테이너 container

---

# bridge, host, none 3개가 기본적으로 있음
# 이름/드라이버 = bridge/bridge, host/host, none/null
docker network ls

# 기본 도커 브리지이며, 이름이 bridge 인 도커 네트워크 정보를 조회
docker network inspect bridge

"Config": [ {
    "Subnet": "172.17.0.0/16",
    "Gateway": "172.17.0.1"
}]
...
"Containers": {
    "0925...": {
        "Name": "docker_net_test_02",
        "IPv4Address": "172.17.0.3/16",
    },
    "b710...": {
        "Name": "docker_net_test_01",
        "IPv4Address": "172.17.0.2/16",
    }
}
...

---

# 브릿지

# 컨테이너들은 연결된 브리지를 통해 외부와 통신 가능

# 새로운 브리지 네트워크 생성
docker network create --driver bridge mybridge
docker network ls

# mybridge 를 사용하는 컨테이너 생성, --net mybridge
docker run -i -t -d --name mynetwork_container --net mybridge ubuntu:14.04
docker exec -it mynetwork_container ifconfig

# 컨테이너에 브릿지 연결, 해제 가능
docker network disconnect mybridge mynetwork_container
docker network connect mybridge mynetwork_container

# 브릿지에 네트워크 임의 대역 설정 가능
docker network create --driver=bridge \
--subnet=172.72.0.0/16 \
--ip-range=172.72.0.0/24 \
--gateway=172.72.0.1 \
my_custom_network
docker network inspect my_custom_network

---

# 호스트 네트워크, --net host
# 컨테이너에서 호스트의 네트워크 환경을 그대로 쓸 수 있다
# host 라는 이름의 네트워크는 생성하지 않고, 도커 기본으로 있는 네트워크이다
docker run -it --name network_host --net host ubuntu:14.04
docker exec -it network_host ifconfig

---

# 논 네트워크, --net none
# 컨테이너가 아무런 네트워크를 사용하지 않음
# 외부와 연결이 단절됨

# ifconfig 결과, 로컬 루프백만 있고, eth0 가 없음
docker run -itd --name network_none --net none ubuntu:14.04
docker exec -it network_none ifconfig

---

# 컨테이너 네트워크, --net container:xxx
# 다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다

docker run -itd --name network_con1 ubuntu:14.04
docker run -itd --name network_con2 --net container:network_con1 ubuntu:14.04

# 맥주소, ip주소 모두 같다
docker exec network_con1 ifconfig
docker exec network_con2 ifconfig

# 컨테이너 네트워크 사용 예시나, 장단점을 모르겠음 !

---

# 브릿지와 --net-alias 옵션
# mybridge 같은 브릿지 사용, myalias01 같은 alias 사용
docker run -itd --name network_alias_con1 --net mybridge --net-alias myalias01 ubuntu:14.04
docker run -itd --name network_alias_con2 --net mybridge --net-alias myalias01 ubuntu:14.04
docker run -itd --name network_alias_con3 --net mybridge --net-alias myalias01 ubuntu:14.04

# ip 주소가 3개 모두 다름
docker inspect --format='IPAddress: {{.NetworkSettings.Networks.mybridge.IPAddress}}' network_alias_con1
docker inspect --format='IPAddress: {{.NetworkSettings.Networks.mybridge.IPAddress}}' network_alias_con2
docker inspect --format='IPAddress: {{.NetworkSettings.Networks.mybridge.IPAddress}}' network_alias_con3

# ping 확인을 위한 컨테이너 생성
docker run -itd --name network_alias_ping --net mybridge ubuntu:14.04
docker exec -it network_alias_ping /bin/bash
ping -c 3 myalias01

# 도커 내장 DNS
# 도커는 사용자 정의 브리지 네트워크에 사용되는 내장 DNS 서버를 가짐

# DNS IP 조회 도구 dig 사용
docker exec -it network_alias_ping /bin/bash
apt-get update && apt-get install dnsutils -y
dig myalias01

---

# 컨테이너 로깅

---

# 컨테이너의 stdout, stderr 로그를 별도의 메타데이터 파일로 저장

# logs 명령어
docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=1234 mysql:5.7
docker logs mysql

# logs 명령어 활용, 일부러 컨테이너 에러 발생
# start 로 다시 시작해도 실행 안됨
# logs 명령어로 에러 원인 파악 가능
# mysql 이미지는 비밀번호 설정 해줘야 실행됨
docker run -d --name no_passwd_mysql mysql:5.7
docker ps --format "table {{.ID}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}"
docker start no_passwd_mysql
docker ps --format "table {{.ID}}\t{{.Status}}\t{{.Ports}}\t{{.Names}}"
docker logs no_passwd_mysql

# logs, tail 옵션
docker logs --tail 2 mysql
docker logs -f -t mysql

# logs, since 옵션, 유닉스 타임
docker logs --since 1766156400 mysql

---

# bash 쉘 등의 입출력 내용도 확인 가능
docker run -it --name logstest ubuntu:14.04
echo test!
docker logs logstest

---

# 컨테이너 로그는 기본적으로 JSON 형태로 저장됨
# 이 파일은 컨테이너 ID 로 시작하는 파일명으로 저장됨
cat /var/lib/docker/containers/${CONTAINER_ID}/${CONTAINER_ID}-json.log

# 맥 docker desktop 으로 실행한 ubuntu logstest 컨테이너 inspect 내용 중 log path
# "LogPath": "/var/lib/docker/containers/asdf.../asdf...-json.log",
# 하지만, /var/lib/docker/containers 파일은 맥에 존재하지 않음

# 경로는 도커 데스크탑이 실행하는, VM 내부 경로임

---

# 맥 VM 내부 접근해서 로그 파일 직접 확인

# 특권 모드 컨테이너를 통해 VM 내부 셸 접속, 주의 !
docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh

# 접속 후 로그 위치로 이동
cd /var/lib/docker/containers/<컨테이너ID>/

---

# 특권 모드 컨테이너 명령어 해석
docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh

# --privileged: 컨테이너가 호스트의 모든 장치(Device)에 접근할 수 있도록 특권 권한을 부여합니다.
# 시스템 레벨의 커널 기능을 조작하기 위해 필수적입니다.

# --pid=host: 컨테이너가 호스트 시스템의 PID 네임스페이스를 공유하도록 합니다.
# 이 옵션을 쓰면 컨테이너 안에서 ps 명령어를 쳤을 때 호스트(가상 머신)에서 돌아가는 모든 프로세스를 볼 수 있게 됩니다.

# nsenter는 'Namespace Enter'의 줄임말로, 특정 프로세스의 네임스페이스에 진입할 때 사용합니다.

# -t 1: 대상 프로세스 ID(PID)를 1번으로 지정합니다.
# 리눅스에서 PID 1은 시스템의 첫 번째 프로세스(init)이므로,
# 사실상 시스템 전체 환경에 들어가겠다는 뜻입니다.
# -m (mount): 호스트의 파일 시스템 마운트 지점을 공유합니다. (호스트의 파일을 보고 수정 가능)
# -u (uts): 호스트의 호스트네임과 도메인 네임을 공유합니다.
# -n (net): 호스트의 네트워크 설정(IP, 포트 등)을 공유합니다.
# -i (ipc): 호스트의 프로세스 간 통신(IPC) 통로를 공유합니다.

# sh: 네임스페이스에 진입한 후 실행할 쉘(Shell) 프로그램입니다.
# 이 명령이 실행되면 당신은 Mac 파일 시스템이 아닌,
# Docker Desktop이 구동되는 "리눅스 가상 머신" 의 내부 쉘에 접속하게 됩니다.

---

# --log-opt, json 로그 파일 옵션 설정 가능
# max-size, max-file
docker run -it \
--log-opt max-size=10k \
--log-opt max-file=3 \
--name log-test ubuntu:14.04

---

# 로깅 드라이버
# json-file
# syslog, journald
# fluentd
# awslogs 등 => 생략

---

# --log-driver 옵션 사용
# 로깅 드라이버는 기본적으로 json-file

# 도커 데몬 시작 옵션 변경으로 적용할 수도 있음
DOCKER_OPTS="--log-driver=syslog"
DOCKER_OPTS="--log-opt max-size=10k --log-opt max-file=3"

---

# syslog
# 유닉스 계열 운영체제에서 로그를 수집하는 오랜 표준

# 리눅스 syslog 조회
# 우분투 14.04 : /var/log/syslog
# 우분투 16.04, coreOS : journalctl -u docker.service
# centos, rhel : /var/log/messages

---

# syslog 테스트, echo 기록도 남는다
docker run -d --name syslog_con --log-driver=syslog ubuntu:14.04
tail /var/log/syslog
echo asdf
tail /var/log/syslog

---

# rsyslog
# syslog 를 원격에 저장하는 방법 중 하나
# 중앙 컨테이너로 로그를 모아보자

# vm 2대 필요
# 서버 호스트 vm 192.168.64.10
# 클라 호스트 vm 192.168.64.11

---

# 서버 vm, -h 옵션, hostname 설정
docker run -it -h rsyslog --name rsyslog_server -p 514:514 -p 514:514/udp ubuntu:14.04

# 서버 vm 컨테이너, rsyslog.conf
vi /etc/rsyslog.conf

# provides UDP syslog reception
$ModLoad imudp
#UDPServerRun 514

# provides TCP syslog reception
$ModLoad imtcp
$InputTcpServerRun 514

# 서버 vm 컨테이너, rsyslog 서비스 재시작
service rsyslog restart

---

# 클라 vm
docker run -it --name=rsyslog_client \
--log-driver=syslog \
--log-opt syslog-address=tcp://192.168.64.10:514 \
--log-opt tag="mylog" \
ubuntu:14.04

---

# 클라 vm, rsyslog_client 컨테이너
docker exec -it rsyslog_client /bin/bash
echo test

# 서버 vm, rsyslog 컨테이너, echo test 로그가 찍힌다
docker exec -it rsyslog_server /bin/bash
tail /var/log/syslog

---

# 트러블 슈팅
# rsyslog_client 컨테이너에서 echo test 했지만, rsyslog_server 컨테이너에서 로그 수집이 안됨

# testvm11 내부(도커 밖)에서 실제 로그 서버로 수동 연결이 되는지 먼저 확인해야 합니다.
# 성공
nc -zv 192.168.64.10 514

# UTM의 공유 네트워크 모드는 macOS의 가상 스위치를 거치기 때문에, 맥 호스트의 설정이 영향을 줄 수 있습니다.
# 맥 시스템 설정: 시스템 설정 > 네트워크 > 방화벽이 켜져 있다면 일시적으로 끄고 테스트해 보세요.
# 포트 충돌: 맥 호스트에서 이미 514 포트를 사용 중인 프로세스가 있는지 확인하세요.
# 맥 터미널에서 실행
# 성공
sudo lsof -i :514

# 클라 vm, tcp 대신 udp 사용
# 서버에서 echo 로그가 찍힘, 성공 !
docker run -it --name=rsyslog_client_udp \
--log-driver=syslog \
--log-opt syslog-address=udp://192.168.64.10:514 \
--log-opt tag="mylog" \
ubuntu:14.04

# 왜 client 에서 syslog tcp 접속하면 로그가 안 찍힐까...

# 컨테이너 이름 변경, tcp 다시 생성
docker run -it --name=rsyslog_client_tcp \
--log-driver=syslog \
--log-opt syslog-address=tcp://192.168.64.10:514 \
--log-opt tag="mylog" \
ubuntu:14.04

# 컨테이너 다시 생성 한 후, 로그 서버에 로그 찍히는 것을 확인
# 컨테이너 run 할 때, rsyslog 서버에서 못 받아주는 상태이면, 컨테이너를 다시 생성해야 한다
# 컨테이너를 stop start 해도 로그 전송이 안되는것으로 보인다

# 결론
# 클라이언트 컨테이너를 udp 모드로 생성 및 로그 수집 테스트 후, tcp 모드로 진행 하자

---

# fluentd 로깅

---

# vm 3대 필요
도커 서버 192.168.0.100 -> 192.168.64.100
fluentd 서버 192.168.0.101 -> 192.168.64.101
몽고db 서버 192.168.0.102 -> 192.168.64.102

---

# 몽고서버, 몽고디비 컨테이너 생성
docker run -h mongodb --name mongodb -d -p 27017:27017 mongo

---

# fluentd 서버, 호스트에서 conf 파일 생성
vi fluent.conf
<source>
  @type forward
</source>

<match docker.**>
  @type mongo
  database nginx
  collection access
  host 192.168.64.102
  port 27017
  flush_interval 10s
</match>

# fluentd 서버, fluent.conf 파일이 있는 폴더에서, 컨테이너 생성
# 도커 허브 fluentd 이미지는 몽고디비 플러그인이 없어서 alicek106 이미지 사용
docker run -d -h fluentd --name fluentd -p 24224:24224 \
-v $(pwd)/fluent.conf:/fluentd/etc/fluent.conf \
-e FLUENTD_CONF=fluent.conf \
alicek106/fluentd:mongo

# alicek106 fluentd 이미지는 amd64 이미지라서 실행 불가 !
# arm64 아키텍처에 맞는 이미지로 fluent 컨테이너 다시 생성
# 아래 트러블 슈팅 참고
docker run -d -h fluentd --name fluentd -p 24224:24224 \
-v $(pwd)/fluent.conf:/fluentd/etc/fluent.conf \
-e FLUENTD_CONF=fluent.conf \
my-fluentd-mongo:v1.16-arm64

---

# 도커 서버, 로그 수집 컨테이너 생성
docker run -h nginx --name nginx -p 80:80 -d \
--log-driver=fluentd \
--log-opt fluentd-address=192.168.64.101:24224 \
--log-opt tag=docker.nginx.webserver \
nginx

---

# 몽고 서버, 로그 수집 확인
# 책에는 mongo 명령어 라고 되어있지만 not found, mongosh 명령어 사용
docker exec -it mongodb mongosh
show dbs
use nginx
show collections

# json 출력이라서, 테이블 형식으로 보기
# docker logs nginx 내용과 동일한 로그가 몽고디비에 저장된 것을 확인
console.table(db['access'].find({}, { time:1, log:1, _id: 0 }).toArray())

---

# 트러블 슈팅, fluentd amd64, arm64 아키텍처 문제

docker: Error response from daemon: image with reference alicek106/fluentd:mongo was found but does not provide the specified platform (linux/arm64)
# alicek106/fluentd:mongo 는 amd64 라서 다시 빌드 해야됨

# 책에 써진 주소로, github 도커 파일 확인 및 수정
# https://github.com/alicek106/start-docker-kubernetes/blob/master/chapter2/fluentd_mongo/Dockerfile

# 도커 파일 수정
mkdir my-fluentd-mongo && vi Dockerfile

# Dockerfile FROM 문에 --platform=linux/arm64 옵션만 붙여서 빌드하니까, pull 받는 도커 이미지가 arm64 가 아님
# arm64 지원 이미지를 찾아됨
# 도커 허브 fluent 홈페이지에서 arm64 지원 이미지 버전을 찾음

# 이미지 메니페스트를 통해 arm64 지원 여부 확인
docker manifest inspect fluent/fluentd:v1.16-debian-1

# 도커 파일 다시 작성
FROM --platform=linux/arm64 fluent/fluentd:v1.16-debian-1

USER root

# Debian 계열이므로 apt-get을 사용하여 필요한 빌드 도구 설치
RUN apt-get update && \
    apt-get install -y --no-install-recommends build-essential ruby-dev && \
    fluent-gem install fluent-plugin-mongo && \
    apt-get purge -y --auto-remove build-essential ruby-dev && \
    rm -rf /var/lib/apt/lists/*

EXPOSE 24284

USER fluent

CMD exec fluentd -c /fluentd/etc/$FLUENTD_CONF -p /fluentd/plugins $FLUENTD_OPT

# 도커 이미지 빌드, prune 으로 로컬 이미지 캐시를 삭제 !
docker builder prune -a -f
docker build -t my-fluentd-mongo:v1.16-arm64 .

# 로컬에 생성된 이미지가 arm64 지원하는 이미지인지 확인
docker inspect my-fluentd-mongo:v1.16-arm64 | grep Architecture

# manifest inspect VS inspect
# inspect는 내 컴퓨터(로컬)에 있는 구체적인 상태를 보고,
# manifest inspect는 원격 저장소(도커 허브 등)에 있는 설계도를 미리 보는 것입니다.

---





















